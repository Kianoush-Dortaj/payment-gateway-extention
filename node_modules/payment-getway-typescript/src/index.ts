import { ApiPromise, WsProvider } from '@polkadot/api';
import { cryptoWaitReady, mnemonicGenerate } from '@polkadot/util-crypto';
import { Keyring } from '@polkadot/keyring';

export class PaymentGateway {
    private api!: ApiPromise;
    private endpoint: string;

    constructor(endpoint: string) {
        this.endpoint = endpoint;
    }

    public async connect(): Promise<ApiPromise> {
        const wsProvider = new WsProvider(this.endpoint);
        this.api = await ApiPromise.create({ provider: wsProvider });
        await this.api.isReady;
        return this.api;
    }

    public async getLatestBlock() {
        const block = await this.api.rpc.chain.getBlock();
        const blockNumber = block.block.header.number.toNumber();
        return blockNumber;
    }

    public async createAccount() {
        await cryptoWaitReady();
        const mnemonic = mnemonicGenerate();
        const keyring = new Keyring({ type: 'sr25519' });
        const newAccount = keyring.addFromUri(mnemonic);
        return { mnemonic, address: newAccount.address };
    }

    public async transfer(account: { mnemonic: string; address: string }, toAddress: string, amount: number) {
        const call = {
            section: 'balances',
            method: 'transfer',
        };

        // Convert the amount to Plancks
        const amountInPlancks = BigInt(amount) * BigInt(1_000_000_000_000);
        const args = [toAddress, amountInPlancks];

        const methodHex = await this._getMethodHex(call, args);

        // Get the nonce for the sender's account
        const nonce = await this.api.rpc.system.accountNextIndex(account.address);

        const blockHash = await this.api.rpc.chain.getBlockHash();
        const blockHeader = await this.api.rpc.chain.getHeader(blockHash);
        const blockNumber = blockHeader.number.toNumber();

        const payload = {
            address: account.address,
            blockHash: this.api.genesisHash,
            blockNumber,
            genesisHash: this.api.genesisHash,
            call,
            args,
            nonce, // Use the nonce from the sender's account
            specVersion: this.api.runtimeVersion.specVersion.toNumber(),
            tip: 0,
            transactionVersion: this.api.runtimeVersion.transactionVersion.toNumber(),
        };

        const signedExtrinsic = await this._signTransaction(account.mnemonic, payload);

        // Submit the transaction and get the result
        const unsub = await signedExtrinsic.send((result) => {
            if (result.status.isInBlock) {
                console.log('Transaction included in block:', result.status.asInBlock.toHex());
                unsub();
            } else if (result.status.isFinalized) {
                console.log('Transaction finalized in block:', result.status.asFinalized.toHex());
                unsub();
            }
        });

        return signedExtrinsic;
    }

    public async subscribeToEvents(eventCallback: (eventData: any) => void) {
        const unsubscribe = await this.api.rpc.chain.subscribeNewHeads(async (header) => {
            const events: any = await this.api.query.system.events.at(header.hash);

            events.forEach((record: any, index: any) => {
                const { event, phase } = record;
                const types = event.typeDef;

                const eventData = {
                    index,
                    section: event.section,
                    method: event.method,
                    phase: phase.toString(),
                    documentation: event.meta.documentation ? event.meta.documentation.toString() : 'No documentation available',
                    data: event.data.map((data: any, index: any) => ({
                        type: types[index].type,
                        value: data.toString(),
                    })),
                };

                eventCallback(eventData);
            });
        });

        return unsubscribe;
    }

    public async subscribeToEventsForAccount(accountAddress: string, eventCallback: (eventData: any) => void) {
        const unsubscribe = await this.api.query.system.events((events: any) => {
            events.forEach((record: any) => {
                const { event, phase } = record;
                const types = event.typeDef;
    
                // Check if the event is related to the specified account
                const isAccountEvent = event.section === 'balances' && event.method === 'Transfer' &&
                    (event.data[0].toString() === accountAddress || event.data[1].toString() === accountAddress);
    
                if (isAccountEvent) {
                    const eventData = {
                        section: event.section,
                        method: event.method,
                        phase: phase.toString(),
                        documentation: event.meta.documentation ? event.meta.documentation.toString() : 'No documentation available',
                        data: event.data.map((data: any, index: any) => ({
                            type: types[index].type,
                            value: data.toString(),
                        })),
                    };
    
                    eventCallback(eventData);
                }
            });
        });
    
        return unsubscribe;
    }
    
    public async getBalance(address: string): Promise<number> {
        try {
          const { data: { free } } = await this.api.query.system.account<any>(address);
          const decimals = this.api.registry.chainDecimals[0];
          const BN = require('@polkadot/util').BN;
          const balanceBN = new BN(free.toString());
          const divisorBN = new BN(10).pow(new BN(decimals));
          const balanceFloat = balanceBN.div(divisorBN).toNumber();
          const balanceDecimal = parseFloat(balanceFloat.toFixed(2));
          return balanceDecimal;
        } catch (error) {
          console.error("Failed to get balance:", error);
          throw error;
        }
      }
      

    private async _signTransaction(mnemonic: string, payload: any) {
        await cryptoWaitReady();
        const keyring = new Keyring({ type: 'sr25519' });
        const userAccount = keyring.addFromUri(mnemonic);
        const { section, method } = payload.call;
        const extrinsic = this.api.tx[section][method](...payload.args);
        const signedExtrinsic = await extrinsic.signAsync(userAccount, { nonce: payload.nonce });

        return signedExtrinsic;
    }

    private async _getMethodHex(call: any, args: any) {
        const { section, method } = call;
        const extrinsicFn = this.api.tx[section][method];
        const extrinsic = extrinsicFn(...args);
        return extrinsic.method.toHex();
    }
}
