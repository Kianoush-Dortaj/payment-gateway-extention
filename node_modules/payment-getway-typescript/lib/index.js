"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentGateway = void 0;
const api_1 = require("@polkadot/api");
const util_crypto_1 = require("@polkadot/util-crypto");
const keyring_1 = require("@polkadot/keyring");
class PaymentGateway {
    constructor(endpoint) {
        this.endpoint = endpoint;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const wsProvider = new api_1.WsProvider(this.endpoint);
            this.api = yield api_1.ApiPromise.create({ provider: wsProvider });
            yield this.api.isReady;
            return this.api;
        });
    }
    getLatestBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const block = yield this.api.rpc.chain.getBlock();
            const blockNumber = block.block.header.number.toNumber();
            return blockNumber;
        });
    }
    createAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, util_crypto_1.cryptoWaitReady)();
            const mnemonic = (0, util_crypto_1.mnemonicGenerate)();
            const keyring = new keyring_1.Keyring({ type: 'sr25519' });
            const newAccount = keyring.addFromUri(mnemonic);
            return { mnemonic, address: newAccount.address };
        });
    }
    transfer(account, toAddress, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const call = {
                section: 'balances',
                method: 'transfer',
            };
            // Convert the amount to Plancks
            const amountInPlancks = BigInt(amount) * BigInt(1000000000000);
            const args = [toAddress, amountInPlancks];
            const methodHex = yield this._getMethodHex(call, args);
            // Get the nonce for the sender's account
            const nonce = yield this.api.rpc.system.accountNextIndex(account.address);
            const blockHash = yield this.api.rpc.chain.getBlockHash();
            const blockHeader = yield this.api.rpc.chain.getHeader(blockHash);
            const blockNumber = blockHeader.number.toNumber();
            const payload = {
                address: account.address,
                blockHash: this.api.genesisHash,
                blockNumber,
                genesisHash: this.api.genesisHash,
                call,
                args,
                nonce,
                specVersion: this.api.runtimeVersion.specVersion.toNumber(),
                tip: 0,
                transactionVersion: this.api.runtimeVersion.transactionVersion.toNumber(),
            };
            const signedExtrinsic = yield this._signTransaction(account.mnemonic, payload);
            // Submit the transaction and get the result
            const unsub = yield signedExtrinsic.send((result) => {
                if (result.status.isInBlock) {
                    console.log('Transaction included in block:', result.status.asInBlock.toHex());
                    unsub();
                }
                else if (result.status.isFinalized) {
                    console.log('Transaction finalized in block:', result.status.asFinalized.toHex());
                    unsub();
                }
            });
            return signedExtrinsic;
        });
    }
    subscribeToEvents(eventCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const unsubscribe = yield this.api.rpc.chain.subscribeNewHeads((header) => __awaiter(this, void 0, void 0, function* () {
                const events = yield this.api.query.system.events.at(header.hash);
                events.forEach((record, index) => {
                    const { event, phase } = record;
                    const types = event.typeDef;
                    const eventData = {
                        index,
                        section: event.section,
                        method: event.method,
                        phase: phase.toString(),
                        documentation: event.meta.documentation ? event.meta.documentation.toString() : 'No documentation available',
                        data: event.data.map((data, index) => ({
                            type: types[index].type,
                            value: data.toString(),
                        })),
                    };
                    eventCallback(eventData);
                });
            }));
            return unsubscribe;
        });
    }
    subscribeToEventsForAccount(accountAddress, eventCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const unsubscribe = yield this.api.query.system.events((events) => {
                events.forEach((record) => {
                    const { event, phase } = record;
                    const types = event.typeDef;
                    // Check if the event is related to the specified account
                    const isAccountEvent = event.section === 'balances' && event.method === 'Transfer' &&
                        (event.data[0].toString() === accountAddress || event.data[1].toString() === accountAddress);
                    if (isAccountEvent) {
                        const eventData = {
                            section: event.section,
                            method: event.method,
                            phase: phase.toString(),
                            documentation: event.meta.documentation ? event.meta.documentation.toString() : 'No documentation available',
                            data: event.data.map((data, index) => ({
                                type: types[index].type,
                                value: data.toString(),
                            })),
                        };
                        eventCallback(eventData);
                    }
                });
            });
            return unsubscribe;
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data: { free } } = yield this.api.query.system.account(address);
                const decimals = this.api.registry.chainDecimals[0];
                const BN = require('@polkadot/util').BN;
                const balanceBN = new BN(free.toString());
                const divisorBN = new BN(10).pow(new BN(decimals));
                const balanceFloat = balanceBN.div(divisorBN).toNumber();
                const balanceDecimal = parseFloat(balanceFloat.toFixed(2));
                return balanceDecimal;
            }
            catch (error) {
                console.error("Failed to get balance:", error);
                throw error;
            }
        });
    }
    _signTransaction(mnemonic, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, util_crypto_1.cryptoWaitReady)();
            const keyring = new keyring_1.Keyring({ type: 'sr25519' });
            const userAccount = keyring.addFromUri(mnemonic);
            const { section, method } = payload.call;
            const extrinsic = this.api.tx[section][method](...payload.args);
            const signedExtrinsic = yield extrinsic.signAsync(userAccount, { nonce: payload.nonce });
            return signedExtrinsic;
        });
    }
    _getMethodHex(call, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { section, method } = call;
            const extrinsicFn = this.api.tx[section][method];
            const extrinsic = extrinsicFn(...args);
            return extrinsic.method.toHex();
        });
    }
}
exports.PaymentGateway = PaymentGateway;
